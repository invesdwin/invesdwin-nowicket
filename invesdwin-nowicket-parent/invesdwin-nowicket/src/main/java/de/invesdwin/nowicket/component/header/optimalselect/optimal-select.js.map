{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///optimal-select.js","webpack:///webpack/bootstrap d714800da52de065b45d","webpack:///./src/index.js","webpack:///./src/optimize.js","webpack:///./src/match.js","webpack:///./src/select.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","optimize","select","undefined","_select2","_select3","_optimize2","_optimize3","selector","element","path","replace","split","length","shortened","pop","current","prePart","join","postPart","pattern","matches","document","querySelectorAll","unshift","optimizePart","slice","trim","test","key","references","i","l","contains","description","tagName","toLowerCase","descendant","type","names","map","name","sort","curr","next","partial","shift","match","_references","_description","node","options","_options$ignore","ignore","ignoreClass","keys","forEach","predicate","toString","RegExp","bind","ignoreAttribute","attribute","defaultPredicate","class","checkId","checkClassGlobal","checkAttributeGlobal","checkTagGlobal","checkClassLocal","checkAttributeLocal","checkTagLocal","checkClassChild","checkAttributeChild","checkTagChild","parentNode","checkClass","className","getAttribute","checkIgnore","checkChild","checkAttribute","attributes","some","attributeName","attributeValue","defaultIgnore","checkTag","tag","parent","getElementsByClassName","getElementsByTagName","children","check","indexOf","getQuerySelector","input","arguments","Array","isArray","getMultiSelector","getSingleSelector","nodeType","Error","_match2","optimized","elements","commonParentNode","commonClassName","commonAttribute","commonTagName","console","log","longer","shorter","classNames","push","_match","_optimize"],"mappings":"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","file":"optimal-select.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = exports.optimize = exports.select = undefined;\n\t\n\tvar _select2 = __webpack_require__(3);\n\t\n\tvar _select3 = _interopRequireDefault(_select2);\n\t\n\tvar _optimize2 = __webpack_require__(1);\n\t\n\tvar _optimize3 = _interopRequireDefault(_optimize2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.select = _select3.default;\n\texports.optimize = _optimize3.default;\n\texports.default = _select3.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = optimize;\n\t/**\n\t * # Optimize\n\t *\n\t * 1.) Improve efficiency through shorter selectors by removing redundancy\n\t * 2.) Improve robustness through selector transformation\n\t */\n\t\n\t/**\n\t * Apply different optimization techniques\n\t * @param  {string}      selector - [description]\n\t * @param  {HTMLElement} element  - [description]\n\t * @return {string}               - [description]\n\t */\n\tfunction optimize(selector, element) {\n\t\n\t  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729)\n\t  var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/);\n\t\n\t  if (path.length < 3) {\n\t    return selector;\n\t  }\n\t\n\t  var shortened = [path.pop()];\n\t  while (path.length > 1) {\n\t    var current = path.pop();\n\t    var prePart = path.join(' ');\n\t    var postPart = shortened.join(' ');\n\t\n\t    var pattern = prePart + ' ' + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length !== 1) {\n\t      shortened.unshift(optimizePart(prePart, current, postPart, element));\n\t    }\n\t  }\n\t  shortened.unshift(path[0]);\n\t  path = shortened;\n\t\n\t  // optimize start + end\n\t  path[0] = optimizePart('', path[0], path.slice(1).join(' '), element);\n\t  path[path.length - 1] = optimizePart(path.slice(0, -1).join(' '), path[path.length - 1], '', element);\n\t\n\t  return path.join(' ').replace(/>/g, '> ').trim();\n\t}\n\t\n\t/**\n\t * Improve a chunk of the selector\n\t * @param  {string}      prePart  - [description]\n\t * @param  {string}      current  - [description]\n\t * @param  {string}      postPart - [description]\n\t * @param  {HTMLElement} element  - [description]\n\t * @return {string}               - [description]\n\t */\n\tfunction optimizePart(prePart, current, postPart, element) {\n\t  if (prePart.length) prePart = prePart + ' ';\n\t  if (postPart.length) postPart = ' ' + postPart;\n\t\n\t  // robustness: attribute without value (generalization)\n\t  if (/\\[*\\]/.test(current)) {\n\t    var key = current.replace(/=.*$/, ']');\n\t    var pattern = '' + prePart + key + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = key;\n\t    } else {\n\t      // robustness: replace specific key-value with tag (heuristic)\n\t      var references = document.querySelectorAll('' + prePart + key);\n\t      for (var i = 0, l = references.length; i < l; i++) {\n\t        if (references[i].contains(element)) {\n\t          var description = references[i].tagName.toLowerCase();\n\t          var pattern = '' + prePart + description + postPart;\n\t          var matches = document.querySelectorAll(pattern);\n\t          if (matches.length === 1 && matches[0] === element) {\n\t            current = description;\n\t          }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // robustness: descendant instead child (heuristic)\n\t  if (/>/.test(current)) {\n\t    var descendant = current.replace(/>/, '');\n\t    var pattern = '' + prePart + descendant + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = descendant;\n\t    }\n\t  }\n\t\n\t  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n\t  if (/\\:nth-child/.test(current)) {\n\t    var type = current.replace(/nth-child/g, 'nth-of-type');\n\t    var pattern = '' + prePart + type + postPart;\n\t    var matches = document.querySelectorAll(pattern);\n\t    if (matches.length === 1 && matches[0] === element) {\n\t      current = type;\n\t    }\n\t  }\n\t\n\t  // efficiency: combinations of classname (partial permutations)\n\t  if (/\\.\\S+\\.\\S+/.test(current)) {\n\t    var names = current.trim().split('.').slice(1).map(function (name) {\n\t      return '.' + name;\n\t    }).sort(function (curr, next) {\n\t      return curr.length - next.length;\n\t    });\n\t    while (names.length) {\n\t      var partial = current.replace(names.shift(), '');\n\t      var pattern = '' + prePart + partial + postPart;\n\t      var matches = document.querySelectorAll(pattern);\n\t      if (matches.length === 1 && matches[0] === element) {\n\t        current = partial;\n\t      }\n\t    }\n\t    // robustness: degrade complex classname (heuristic)\n\t    if (current && current.match(/\\./g).length > 2) {\n\t      var _references = document.querySelectorAll('' + prePart + current);\n\t      for (var i = 0, l = _references.length; i < l; i++) {\n\t        if (_references[i].contains(element)) {\n\t          // TODO:\n\t          // - check using attributes + regard excludes\n\t          var _description = _references[i].tagName.toLowerCase();\n\t          var pattern = '' + prePart + _description + postPart;\n\t          var matches = document.querySelectorAll(pattern);\n\t          if (matches.length === 1 && matches[0] === element) {\n\t            current = _description;\n\t          }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  return current;\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = match;\n\t/**\n\t * # Match\n\t *\n\t * Retrieves selector\n\t */\n\t\n\tvar defaultIgnore = {\n\t  attribute: function attribute(attributeName) {\n\t    return ['style', 'data-reactid', 'data-react-checksum'].indexOf(attributeName) > -1;\n\t  }\n\t};\n\t\n\t/**\n\t * Get the path of the element\n\t * @param  {HTMLElement} node    - [description]\n\t * @param  {Object}      options - [description]\n\t * @return {String}              - [description]\n\t */\n\tfunction match(node, options) {\n\t  var path = [];\n\t  var element = node;\n\t  var length = path.length;\n\t\n\t  var _options$ignore = options.ignore;\n\t  var ignore = _options$ignore === undefined ? {} : _options$ignore;\n\t\n\t\n\t  var ignoreClass = false;\n\t  Object.keys(ignore).forEach(function (type) {\n\t    if (type === 'class') {\n\t      ignoreClass = true;\n\t    }\n\t    var predicate = ignore[type];\n\t    if (typeof predicate === 'function') return;\n\t    if (typeof predicate === 'number') {\n\t      predicate = predicate.toString();\n\t    }\n\t    if (typeof predicate === 'string') {\n\t      predicate = new RegExp(predicate);\n\t    }\n\t    // check class-/attributename for regex\n\t    ignore[type] = predicate.test.bind(predicate);\n\t  });\n\t  if (ignoreClass) {\n\t    (function () {\n\t      var ignoreAttribute = ignore.attribute;\n\t      ignore.attribute = function (name, value, defaultPredicate) {\n\t        return ignore.class(value) || ignoreAttribute && ignoreAttribute(name, value, defaultPredicate);\n\t      };\n\t    })();\n\t  }\n\t\n\t  while (element !== document) {\n\t    // global\n\t    if (checkId(element, path, ignore)) break;\n\t    if (checkClassGlobal(element, path, ignore)) break;\n\t    if (checkAttributeGlobal(element, path, ignore)) break;\n\t    if (checkTagGlobal(element, path, ignore)) break;\n\t\n\t    // local\n\t    checkClassLocal(element, path, ignore);\n\t\n\t    // define only one selector each iteration\n\t    if (path.length === length) {\n\t      checkAttributeLocal(element, path, ignore);\n\t    }\n\t    if (path.length === length) {\n\t      checkTagLocal(element, path, ignore);\n\t    }\n\t\n\t    if (path.length === length) {\n\t      checkClassChild(element, path, ignore);\n\t    }\n\t    if (path.length === length) {\n\t      checkAttributeChild(element, path, ignore);\n\t    }\n\t    if (path.length === length) {\n\t      checkTagChild(element, path, ignore);\n\t    }\n\t\n\t    element = element.parentNode;\n\t    length = path.length;\n\t  }\n\t\n\t  if (element === document) {\n\t    path.unshift('*');\n\t  }\n\t\n\t  return path.join(' ');\n\t}\n\t\n\t/**\n\t * [checkClassGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassGlobal(element, path, ignore) {\n\t  return checkClass(element, path, ignore, document);\n\t}\n\t\n\t/**\n\t * [checkClassLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassLocal(element, path, ignore) {\n\t  return checkClass(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkClassChild description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClassChild(element, path, ignore) {\n\t  var className = element.getAttribute('class');\n\t  if (checkIgnore(ignore.class, className)) {\n\t    return false;\n\t  }\n\t  return checkChild(element, path, '.' + className.trim().replace(/\\s+/g, '.'));\n\t}\n\t\n\t/**\n\t * [checkAttributeGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeGlobal(element, path, ignore) {\n\t  return checkAttribute(element, path, ignore, document);\n\t}\n\t\n\t/**\n\t * [checkAttributeLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeLocal(element, path, ignore) {\n\t  return checkAttribute(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkAttributeChild description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttributeChild(element, path, ignore) {\n\t  var attributes = element.attributes;\n\t  return Object.keys(attributes).some(function (key) {\n\t    var attribute = attributes[key];\n\t    var attributeName = attribute.name;\n\t    var attributeValue = attribute.value;\n\t    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n\t      return false;\n\t    }\n\t    var pattern = '[' + attributeName + '=\"' + attributeValue + '\"]';\n\t    return checkChild(element, path, pattern);\n\t  });\n\t}\n\t\n\t/**\n\t * [checkTagGlobal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagGlobal(element, path, ignore) {\n\t  return checkTag(element, path, ignore, document);\n\t}\n\t\n\t/**\n\t * [checkTagLocal description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagLocal(element, path, ignore) {\n\t  return checkTag(element, path, ignore, element.parentNode);\n\t}\n\t\n\t/**\n\t * [checkTabChildren description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTagChild(element, path, ignore) {\n\t  var tagName = element.tagName.toLowerCase();\n\t  if (checkIgnore(ignore.tag, tagName)) {\n\t    return false;\n\t  }\n\t  return checkChild(element, path, tagName);\n\t}\n\t\n\t/**\n\t * [checkId description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkId(element, path, ignore) {\n\t  var id = element.id;\n\t  if (checkIgnore(ignore.id, id)) {\n\t    return false;\n\t  }\n\t  path.unshift('#' + id);\n\t  return true;\n\t}\n\t\n\t/**\n\t * [checkClass description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkClass(element, path, ignore, parent) {\n\t  var className = element.getAttribute('class');\n\t  if (checkIgnore(ignore.class, className)) {\n\t    return false;\n\t  }\n\t  var matches = parent.getElementsByClassName(className);\n\t  if (matches.length === 1) {\n\t    path.unshift('.' + className.trim().replace(/\\s+/g, '.'));\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkAttribute description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkAttribute(element, path, ignore, parent) {\n\t  var attributes = element.attributes;\n\t  return Object.keys(attributes).some(function (key) {\n\t    var attribute = attributes[key];\n\t    var attributeName = attribute.name;\n\t    var attributeValue = attribute.value;\n\t    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n\t      return false;\n\t    }\n\t    var pattern = '[' + attributeName + '=\"' + attributeValue + '\"]';\n\t    var matches = parent.querySelectorAll(pattern);\n\t    if (matches.length === 1) {\n\t      path.unshift(pattern);\n\t      return true;\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * [checkTag description]\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Array}       path    - [description]\n\t * @param  {HTMLElement} parent  - [description]\n\t * @param  {Object}      ignore  - [description]\n\t * @return {Boolean}             - [description]\n\t */\n\tfunction checkTag(element, path, ignore, parent) {\n\t  var tagName = element.tagName.toLowerCase();\n\t  if (checkIgnore(ignore.tag, tagName)) {\n\t    return false;\n\t  }\n\t  var matches = parent.getElementsByTagName(tagName);\n\t  if (matches.length === 1) {\n\t    path.unshift(tagName);\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkChild description]\n\t * @param  {HTMLElement} element  - [description]\n\t * @param  {Array}       path     - [description]\n\t * @param  {String}      selector - [description]\n\t * @return {Boolean}              - [description]\n\t */\n\tfunction checkChild(element, path, selector) {\n\t  var parent = element.parentNode;\n\t  var children = parent.children;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    if (children[i] === element) {\n\t      path.unshift('> ' + selector + ':nth-child(' + (i + 1) + ')');\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * [checkIgnore description]\n\t * @param  {Function} predicate        [description]\n\t * @param  {string}   name             [description]\n\t * @param  {string}   value            [description]\n\t * @param  {Function} defaultPredicate [description]\n\t * @return {boolean}                   [description]\n\t */\n\tfunction checkIgnore(predicate, name, value, defaultPredicate) {\n\t  if (!name) {\n\t    return true;\n\t  }\n\t  var check = predicate || defaultPredicate;\n\t  if (!check) {\n\t    return false;\n\t  }\n\t  return check(name, value, defaultPredicate);\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = getQuerySelector;\n\texports.getSingleSelector = getSingleSelector;\n\texports.getMultiSelector = getMultiSelector;\n\t\n\tvar _match = __webpack_require__(2);\n\t\n\tvar _match2 = _interopRequireDefault(_match);\n\t\n\tvar _optimize = __webpack_require__(1);\n\t\n\tvar _optimize2 = _interopRequireDefault(_optimize);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Choose action depending on the input (single/multi)\n\t * @param  {HTMLElement|Array} input   - [description]\n\t * @param  {Object}            options - [description]\n\t * @return {string}                    - [description]\n\t */\n\t/**\n\t * # Select\n\t *\n\t * Construct a unique CSS queryselector to access the selected DOM element(s).\n\t * Applies different matching and optimization strategies for efficiency.\n\t */\n\t\n\tfunction getQuerySelector(input) {\n\t  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t  if (Array.isArray(input)) {\n\t    return getMultiSelector(input, options);\n\t  }\n\t  return getSingleSelector(input, options);\n\t}\n\t\n\t/**\n\t * Get a selector for the provided element\n\t * @param  {HTMLElement} element - [description]\n\t * @param  {Object}      options - [description]\n\t * @return {String}              - [description]\n\t */\n\tfunction getSingleSelector(element, options) {\n\t\n\t  if (element.nodeType === 3) {\n\t    return getSingleSelector(element.parentNode);\n\t  }\n\t  if (element.nodeType !== 1) {\n\t    throw new Error('Invalid input!');\n\t  }\n\t\n\t  var selector = (0, _match2.default)(element, options);\n\t  var optimized = (0, _optimize2.default)(selector, element);\n\t\n\t  // debug\n\t  // console.log(`\n\t  //   selector: ${selector}\n\t  //   optimized:${optimized}\n\t  // `)\n\t\n\t  return optimized;\n\t}\n\t\n\t/**\n\t * Get a selector to match multiple children from a parent\n\t * @param  {Array}  elements - [description]\n\t * @param  {Object} options  - [description]\n\t * @return {string}          - [description]\n\t */\n\tfunction getMultiSelector(elements, options) {\n\t  var commonParentNode = null;\n\t  var commonClassName = null;\n\t  var commonAttribute = null;\n\t  var commonTagName = null;\n\t\n\t  for (var i = 0, l = elements.length; i < l; i++) {\n\t    var element = elements[i];\n\t    if (!commonParentNode) {\n\t      // 1st entry\n\t      commonParentNode = element.parentNode;\n\t      commonClassName = element.className;\n\t      // commonAttribute = element.attributes\n\t      commonTagName = element.tagName;\n\t    } else if (commonParentNode !== element.parentNode) {\n\t      return console.log('Can\\'t be efficiently mapped. It probably best to use multiple single selectors instead!');\n\t    }\n\t    if (element.className !== commonClassName) {\n\t      var classNames = [];\n\t      var longer, shorter;\n\t      if (element.className.length > commonClassName.length) {\n\t        longer = element.className;\n\t        shorter = commonClassName;\n\t      } else {\n\t        longer = commonClassName;\n\t        shorter = element.className;\n\t      }\n\t      shorter.split(' ').forEach(function (name) {\n\t        if (longer.indexOf(name) > -1) {\n\t          classNames.push(name);\n\t        }\n\t      });\n\t      commonClassName = classNames.join(' ');\n\t    }\n\t    // TODO:\n\t    // - check attributes\n\t    // if (element.attributes !== commonAttribute) {\n\t    //\n\t    // }\n\t    if (element.tagName !== commonTagName) {\n\t      commonTagName = null;\n\t    }\n\t  }\n\t\n\t  var selector = getSingleSelector(commonParentNode);\n\t  console.log(selector, commonClassName, commonAttribute, commonTagName);\n\t\n\t  if (commonClassName) {\n\t    return selector + ' > .' + commonClassName.replace(/ /g, '.');\n\t  }\n\t  // if (commonAttribute) {\n\t  //\n\t  // }\n\t  if (commonTagName) {\n\t    return selector + ' > ' + commonTagName.toLowerCase();\n\t  }\n\t  return selector + ' > *';\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** optimal-select.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d714800da52de065b45d\n **/","export select from './select'\nexport optimize from './optimize'\n\nexport default from './select'\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\n/**\n * Apply different optimization techniques\n * @param  {string}      selector - [description]\n * @param  {HTMLElement} element  - [description]\n * @return {string}               - [description]\n */\nexport default function optimize (selector, element) {\n\n  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729)\n  var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)\n\n  if (path.length < 3) {\n    return selector\n  }\n\n  const shortened = [path.pop()]\n  while (path.length > 1)  {\n    const current = path.pop()\n    const prePart = path.join(' ')\n    const postPart = shortened.join(' ')\n\n    const pattern = `${prePart} ${postPart}`\n    const matches = document.querySelectorAll(pattern)\n    if (matches.length !== 1) {\n      shortened.unshift(optimizePart(prePart, current, postPart, element))\n    }\n  }\n  shortened.unshift(path[0])\n  path = shortened\n\n  // optimize start + end\n  path[0] = optimizePart('', path[0], path.slice(1).join(' '), element)\n  path[path.length-1] = optimizePart(path.slice(0, -1).join(' '), path[path.length-1], '', element)\n\n  return path.join(' ').replace(/>/g, '> ').trim()\n}\n\n/**\n * Improve a chunk of the selector\n * @param  {string}      prePart  - [description]\n * @param  {string}      current  - [description]\n * @param  {string}      postPart - [description]\n * @param  {HTMLElement} element  - [description]\n * @return {string}               - [description]\n */\nfunction optimizePart (prePart, current, postPart, element) {\n  if (prePart.length) prePart = `${prePart} `\n  if (postPart.length) postPart = ` ${postPart}`\n\n  // robustness: attribute without value (generalization)\n  if (/\\[*\\]/.test(current)) {\n    const key = current.replace(/=.*$/, ']')\n    var pattern = `${prePart}${key}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = key\n    } else {\n      // robustness: replace specific key-value with tag (heuristic)\n      const references = document.querySelectorAll(`${prePart}${key}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        if (references[i].contains(element)) {\n          const description = references[i].tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (matches.length === 1 && matches[0] === element) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  // robustness: descendant instead child (heuristic)\n  if (/>/.test(current)) {\n    const descendant = current.replace(/>/, '')\n    var pattern = `${prePart}${descendant}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = descendant\n    }\n  }\n\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (/\\:nth-child/.test(current)) {\n    const type = current.replace(/nth-child/g, 'nth-of-type')\n    var pattern = `${prePart}${type}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (matches.length === 1 && matches[0] === element) {\n      current = type\n    }\n  }\n\n  // efficiency: combinations of classname (partial permutations)\n  if (/\\.\\S+\\.\\S+/.test(current)) {\n    const names = current.trim().split('.').slice(1).map((name) => `.${name}`)\n                                .sort((curr, next) => curr.length - next.length)\n    while (names.length) {\n      var partial = current.replace(names.shift(), '')\n      var pattern = `${prePart}${partial}${postPart}`\n      var matches = document.querySelectorAll(pattern)\n      if (matches.length === 1 && matches[0] === element) {\n        current = partial\n      }\n    }\n    // robustness: degrade complex classname (heuristic)\n    if (current && current.match(/\\./g).length > 2) {\n      const references = document.querySelectorAll(`${prePart}${current}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        if (references[i].contains(element)) {\n          // TODO:\n          // - check using attributes + regard excludes\n          const description = references[i].tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (matches.length === 1 && matches[0] === element) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return current\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/optimize.js\n **/","/**\n * # Match\n *\n * Retrieves selector\n */\n\nconst defaultIgnore = {\n  attribute (attributeName) {\n    return [\n      'style',\n      'data-reactid',\n      'data-react-checksum'\n    ].indexOf(attributeName) > -1\n  }\n}\n\n/**\n * Get the path of the element\n * @param  {HTMLElement} node    - [description]\n * @param  {Object}      options - [description]\n * @return {String}              - [description]\n */\nexport default function match (node, options) {\n  const path = []\n  var element = node\n  var length = path.length\n\n  const { ignore = {} } = options\n\n  var ignoreClass = false\n  Object.keys(ignore).forEach((type) => {\n    if (type === 'class') {\n      ignoreClass = true\n    }\n    var predicate = ignore[type]\n    if (typeof predicate === 'function') return\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(predicate)\n    }\n    // check class-/attributename for regex\n    ignore[type] = predicate.test.bind(predicate)\n  })\n  if (ignoreClass) {\n    const ignoreAttribute = ignore.attribute\n    ignore.attribute = (name, value, defaultPredicate) => {\n      return ignore.class(value) || ignoreAttribute && ignoreAttribute(name, value, defaultPredicate)\n    }\n  }\n\n  while (element !== document) {\n    // global\n    if (checkId(element, path, ignore)) break\n    if (checkClassGlobal(element, path, ignore)) break\n    if (checkAttributeGlobal(element, path, ignore)) break\n    if (checkTagGlobal(element, path, ignore)) break\n\n    // local\n    checkClassLocal(element, path, ignore)\n\n    // define only one selector each iteration\n    if (path.length === length) {\n      checkAttributeLocal(element, path, ignore)\n    }\n    if (path.length === length) {\n      checkTagLocal(element, path, ignore)\n    }\n\n    if (path.length === length) {\n      checkClassChild(element, path, ignore)\n    }\n    if (path.length === length) {\n      checkAttributeChild(element, path, ignore)\n    }\n    if (path.length === length) {\n      checkTagChild(element, path, ignore)\n    }\n\n    element = element.parentNode\n    length = path.length\n  }\n\n  if (element === document) {\n    path.unshift('*')\n  }\n\n  return path.join(' ')\n}\n\n\n/**\n * [checkClassGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassGlobal (element, path, ignore) {\n  return checkClass(element, path, ignore, document)\n}\n\n/**\n * [checkClassLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassLocal (element, path, ignore) {\n  return checkClass(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkClassChild description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClassChild (element, path, ignore) {\n  const className = element.getAttribute('class')\n  if (checkIgnore(ignore.class, className)) {\n    return false\n  }\n  return checkChild(element, path, `.${className.trim().replace(/\\s+/g, '.')}`)\n}\n\n/**\n * [checkAttributeGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeGlobal (element, path, ignore) {\n  return checkAttribute(element, path, ignore, document)\n}\n\n/**\n * [checkAttributeLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeLocal (element, path, ignore) {\n  return checkAttribute(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkAttributeChild description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttributeChild (element, path, ignore) {\n  const attributes = element.attributes\n  return Object.keys(attributes).some((key) => {\n    const attribute = attributes[key]\n    const attributeName = attribute.name\n    const attributeValue = attribute.value\n    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n      return false\n    }\n    const pattern = `[${attributeName}=\"${attributeValue}\"]`\n    return checkChild(element, path, pattern)\n  })\n}\n\n/**\n * [checkTagGlobal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagGlobal (element, path, ignore) {\n  return checkTag(element, path, ignore, document)\n}\n\n/**\n * [checkTagLocal description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagLocal (element, path, ignore) {\n  return checkTag(element, path, ignore, element.parentNode)\n}\n\n/**\n * [checkTabChildren description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTagChild (element, path, ignore) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, tagName)) {\n    return false\n  }\n  return checkChild(element, path, tagName)\n}\n\n/**\n * [checkId description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkId (element, path, ignore) {\n  const id = element.id\n  if (checkIgnore(ignore.id, id)) {\n    return false\n  }\n  path.unshift(`#${id}`)\n  return true\n}\n\n/**\n * [checkClass description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @param  {HTMLElement} parent  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkClass (element, path, ignore, parent) {\n  const className = element.getAttribute('class')\n  if (checkIgnore(ignore.class, className)) {\n    return false\n  }\n  const matches = parent.getElementsByClassName(className)\n  if (matches.length === 1) {\n    path.unshift(`.${className.trim().replace(/\\s+/g, '.')}`)\n    return true\n  }\n  return false\n}\n\n/**\n * [checkAttribute description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {Object}      ignore  - [description]\n * @param  {HTMLElement} parent  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkAttribute (element, path, ignore, parent) {\n  const attributes = element.attributes\n  return Object.keys(attributes).some((key) => {\n    const attribute = attributes[key]\n    const attributeName = attribute.name\n    const attributeValue = attribute.value\n    if (checkIgnore(ignore.attribute, attributeName, attributeValue, defaultIgnore.attribute)) {\n      return false\n    }\n    const pattern = `[${attributeName}=\"${attributeValue}\"]`\n    const matches = parent.querySelectorAll(pattern)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      return true\n    }\n  })\n}\n\n/**\n * [checkTag description]\n * @param  {HTMLElement} element - [description]\n * @param  {Array}       path    - [description]\n * @param  {HTMLElement} parent  - [description]\n * @param  {Object}      ignore  - [description]\n * @return {Boolean}             - [description]\n */\nfunction checkTag (element, path, ignore, parent) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, tagName)) {\n    return false\n  }\n  const matches = parent.getElementsByTagName(tagName)\n  if (matches.length === 1) {\n    path.unshift(tagName)\n    return true\n  }\n  return false\n}\n\n/**\n * [checkChild description]\n * @param  {HTMLElement} element  - [description]\n * @param  {Array}       path     - [description]\n * @param  {String}      selector - [description]\n * @return {Boolean}              - [description]\n */\nfunction checkChild (element, path, selector) {\n  const parent = element.parentNode\n  const children = parent.children\n  for (var i = 0, l = children.length; i < l; i++) {\n    if (children[i] === element) {\n      path.unshift(`> ${selector}:nth-child(${i+1})`)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * [checkIgnore description]\n * @param  {Function} predicate        [description]\n * @param  {string}   name             [description]\n * @param  {string}   value            [description]\n * @param  {Function} defaultPredicate [description]\n * @return {boolean}                   [description]\n */\nfunction checkIgnore (predicate, name, value, defaultPredicate) {\n  if (!name) {\n    return true\n  }\n  const check = predicate || defaultPredicate\n  if (!check) {\n    return false\n  }\n  return check(name, value, defaultPredicate)\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/match.js\n **/","/**\n * # Select\n *\n * Construct a unique CSS queryselector to access the selected DOM element(s).\n * Applies different matching and optimization strategies for efficiency.\n */\n\nimport match from './match'\nimport optimize from './optimize'\n\n/**\n * Choose action depending on the input (single/multi)\n * @param  {HTMLElement|Array} input   - [description]\n * @param  {Object}            options - [description]\n * @return {string}                    - [description]\n */\nexport default function getQuerySelector (input, options = {}) {\n  if (Array.isArray(input)) {\n    return getMultiSelector(input, options)\n  }\n  return getSingleSelector(input, options)\n}\n\n/**\n * Get a selector for the provided element\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {String}              - [description]\n */\nexport function getSingleSelector (element, options) {\n\n  if (element.nodeType === 3) {\n    return getSingleSelector(element.parentNode)\n  }\n  if (element.nodeType !== 1) {\n    throw new Error('Invalid input!')\n  }\n\n  const selector = match(element, options)\n  const optimized = optimize(selector, element)\n\n  // debug\n  // console.log(`\n  //   selector: ${selector}\n  //   optimized:${optimized}\n  // `)\n\n  return optimized\n}\n\n/**\n * Get a selector to match multiple children from a parent\n * @param  {Array}  elements - [description]\n * @param  {Object} options  - [description]\n * @return {string}          - [description]\n */\nexport function getMultiSelector (elements, options) {\n  var commonParentNode = null\n  var commonClassName = null\n  var commonAttribute = null\n  var commonTagName = null\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    var element = elements[i]\n    if (!commonParentNode) { // 1st entry\n      commonParentNode = element.parentNode\n      commonClassName = element.className\n      // commonAttribute = element.attributes\n      commonTagName = element.tagName\n    } else if (commonParentNode !== element.parentNode) {\n      return console.log('Can\\'t be efficiently mapped. It probably best to use multiple single selectors instead!')\n    }\n    if (element.className !== commonClassName) {\n      var classNames = []\n      var longer, shorter\n      if (element.className.length > commonClassName.length) {\n        longer = element.className\n        shorter = commonClassName\n      } else {\n        longer = commonClassName\n        shorter = element.className\n      }\n      shorter.split(' ').forEach((name) => {\n        if (longer.indexOf(name) > -1) {\n          classNames.push(name)\n        }\n      })\n      commonClassName = classNames.join(' ')\n    }\n    // TODO:\n    // - check attributes\n    // if (element.attributes !== commonAttribute) {\n    //\n    // }\n    if (element.tagName !== commonTagName) {\n      commonTagName = null\n    }\n  }\n\n  const selector = getSingleSelector(commonParentNode)\n  console.log(selector, commonClassName, commonAttribute, commonTagName)\n\n  if (commonClassName) {\n    return `${selector} > .${commonClassName.replace(/ /g, '.')}`\n  }\n  // if (commonAttribute) {\n  //\n  // }\n  if (commonTagName) {\n    return `${selector} > ${commonTagName.toLowerCase()}`\n  }\n  return `${selector} > *`\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/select.js\n **/"],"sourceRoot":""}